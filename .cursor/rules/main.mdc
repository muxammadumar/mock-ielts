---
name: Main rules
description: This rule covers all the rules in this project
---

# Overview

# Mock IELTS Platform - Cursor Rules

You are a senior frontend engineer specializing in Vue 3 + TypeScript applications optimized for mobile webview usage in superapps.

## PROJECT CONTEXT

- Platform: Mock IELTS testing platform
- Target: Mobile webview in superapps (Click, Telegram, etc.)
- Tech Stack: Vue 3 + TypeScript + Vite + Vant UI
- Build Tool: Vite 6
- UI Library: Vant 4 (mobile-first component library)

## FRAMEWORK & STACK

- Vue 3 only - Always use Composition API
- Always use `<script setup lang="ts">` syntax
- Never use Options API
- TypeScript is mandatory in all frontend code
- Use Vite for build tooling
- Use Vant components for UI (auto-imported via unplugin-vue-components)
- Use Pinia for state management
- Use Vue Router for routing
- Use Axios for HTTP requests
- Use VueUse composables when available
- If you use VueUse always remind about it in the chat

## PROJECT STRUCTURE

- `src/components/` - Reusable Vue components
  - `src/components/common/` - Common UI components
- `src/composables/` - Vue composables (use\* naming convention)
- `src/views/` - Page-level components
- `src/layout/` - Layout components
- `src/router/` - Vue Router configuration
- `src/stores/` - Pinia stores
- `src/services/` - API service functions
- `src/types/` - TypeScript type definitions
- `src/utils/` - Utility functions
- `src/styles/` - Global styles (SCSS)
  - `src/styles/variables.scss` - CSS variables
  - `src/styles/main.scss` - Global styles

## PATH ALIASES

- Always use `@/` alias for `src/` directory
- Example: `import { apiClient } from '@/services'`
- Never use relative paths like `../../` when `@/` can be used

## TYPESCRIPT RULES

- Avoid `any` completely - use `unknown` if type is truly unknown
- Use explicit interfaces and types for all props, emits, and composables
- Do not assume API response shapes - define types in `src/types/`
- Always ask if u are not sure about API responses
- Prefer readable types over overly clever generics
- Use type imports: `import type { User } from '@/types'`
- Define component props with `defineProps<T>()` or `withDefaults(defineProps<T>(), {})`
- Define emits with `defineEmits<{ event: [payload: Type] }>()`

## CODE STYLE

- Prefer arrow functions
- Use early returns to reduce nesting
- Avoid deep nesting (max 3 levels)
- Keep functions small and single-purpose
- Strongly follow DRY principles
- Extract reusable logic into composables instead of duplicating code
- Use const assertions for readonly data: `as const`
- Use template literals for string concatenation

## VUE COMPONENT RULES

- Always use `<script setup lang="ts">`
- Component file names: PascalCase (e.g., `UserProfile.vue`)
- Props: Use `defineProps<T>()` with TypeScript interfaces
- Emits: Use `defineEmits<T>()` with TypeScript types
- Computed: Prefer computed over watchers when possible
- Ref/Reactive: Prefer `ref()` for all cases - better TypeScript support and easier to work with
- Use `reactive()` only for plain objects that won't be reassigned
- Avoid mixing ref and reactive in same component
- Template: Keep logic out of templates - use computed properties or methods
- Avoid v-if and v-for on same element - use template wrapper
- Use key attribute for v-for with unique identifiers

## STATE MANAGEMENT (PINIA)

- Store files: camelCase with `use` prefix (e.g., `useAuthStore.ts`)
- Define stores with `defineStore()` using setup syntax
- Export store composables from `src/stores/`
- Keep stores focused and single-purpose
- Use getters for derived state
- Actions should be async when needed

## ROUTING (VUE ROUTER)

- Route definitions in `src/router/index.ts`
- Use named routes for navigation
- Use route meta for page-level configuration
- Lazy load routes: `component: () => import('@/views/Page.vue')`
- Use route guards when needed (navigation guards in router config)

## API & SERVICES

- All API calls through `src/services/index.ts` (apiClient)
- Create service functions in `src/services/` directory
- Use TypeScript interfaces for request/response types
- Handle errors appropriately - never silently ignore. Error should be always visible if high priority on UI if low priority in the console
- Use async/await, not promise chains
- Define API types in `src/types/` directory
- Standard error handling pattern:

```typescript
try {
  const data = await apiClient.get('/endpoint')
  return data
} catch (error) {
  console.error('Error fetching data:', error)
  showToast({ message: 'Failed to load data', type: 'fail' })
  throw error // re-throw if caller needs to handle
}
```

## STYLING

- Use SCSS for all styles
- Use SCSS variables from `src/styles/variables.scss`
- Use Tailwind CSS classes when appropriate (if added later)
- Scoped styles: `<style scoped lang="scss">`
- Global styles: `src/styles/main.scss`
- Mobile-first approach - design for mobile, enhance for larger screens (later or if asked)
- Use Vant's built-in classes and CSS variables when possible
- Safe area insets: Use CSS variables `--safe-area-inset-*` for notch/status bar

## MOBILE WEBVIEW OPTIMIZATIONS

- Always consider mobile viewport constraints
- Use touch-friendly targets (min 44x44px)
- Optimize images and assets for mobile
- Consider safe area insets for devices with notches
- Test in webview environments
- Avoid fixed positioning that conflicts with safe areas
- Use `viewport-fit=cover` meta tag (already in index.html)
- Disable text selection where not needed: `user-select: none`
- Prevent zoom: Use `maximum-scale=1` in viewport if needed
- Handle back button navigation in superapp webviews
- Use `touch-action` CSS property to optimize scrolling
- Test with Click/Telegram WebView APIs if integration needed
- Consider network conditions - implement offline states

## PERFORMANCE

- Lazy load routes
- Use code splitting (already configured in vite.config.ts)
- Optimize images (use appropriate formats, sizes)
- Avoid unnecessary re-renders
- Use `v-memo` for expensive list rendering when appropriate
- Use `shallowRef` or `shallowReactive` for large objects that don't need deep reactivity

## ERROR HANDLING

- Handle errors explicitly - never silently ignore
- Use try-catch for async operations
- Provide user-friendly error messages
- Log errors appropriately (console.error in development)
- Surface errors clearly for UI handling

## NAMING CONVENTIONS

- Components: PascalCase (e.g., `UserProfile.vue`, `TestCard.vue`)
- Composables: camelCase starting with `use` (e.g., `useAuth.ts`, `useTestData.ts`)
- Stores: camelCase starting with `use` + `Store` suffix (e.g., `useAuthStore.ts`)
- Services: camelCase (e.g., `authService.ts`, `testService.ts`)
- Types/Interfaces: PascalCase without prefix (e.g., `User`, `TestResult`, `ApiResponse`)
- Type aliases: PascalCase with `Type` suffix if needed for clarity (e.g., `UserType`, `ConfigType`)
- Constants: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)
- Variables/Functions: camelCase (e.g., `getUserData`, `testResults`)

## FILE NAMING

- Components: PascalCase (e.g., `UserProfile.vue`)
- Composables: camelCase with `use` prefix (e.g., `useAuth.ts`)
- Services: camelCase with descriptive name (e.g., `authService.ts`)
- Types: camelCase (e.g., `user.ts` or `index.ts` with exports)
- Utils: camelCase (e.g., `formatDate.ts` or grouped in `index.ts`)

## VANT UI LIBRARY

- Vant components are auto-imported - no need to import manually
- Use Vant components directly in templates
- Follow Vant's design patterns and API
- Customize Vant theme via CSS variables when needed
- Use Vant's built-in form validation when possible
- Prefer Vant's mobile-optimized components over custom implementations
- Use Toast/Dialog/Notify for user feedback instead of alert()
- Use Vant's List component for infinite scroll/pagination
- Leverage Vant's form components (Field, Form) with built-in validation

## AUTO-IMPORTS

- Vue composables (ref, computed, watch, etc.) are auto-imported
- Vue Router (useRouter, useRoute) are auto-imported
- Pinia (defineStore, storeToRefs) are auto-imported
- No need to import these manually

## COMPOSABLES BEST PRACTICES

- Return objects, not arrays (better for destructuring with names)
- Always return reactive values (ref/computed)
- Example:

```typescript
// Good
export function useCounter() {
  const count = ref(0)
  const increment = () => count.value++
  return { count, increment }
}

// Avoid
export function useCounter() {
  const count = ref(0)
  return [count, () => count.value++] // unclear what index 1 is
}
```

## ENVIRONMENT VARIABLES

- Prefix all env vars with `VITE_` to expose to client
- Define types in `src/vite-env.d.ts` or `src/types/env.d.ts`
- Never commit `.env` files - use `.env.example` template
- Access via `import.meta.env.VITE_*`
- Example:

```typescript
const apiUrl = import.meta.env.VITE_API_URL
```

## COMMENTS & DOCUMENTATION

- Write self-documenting code - prefer clear naming over comments
- Use JSDoc for public APIs and complex functions
- Avoid obvious comments like `// increment counter`
- Use TODO comments with issue references: `// TODO(#123): Fix edge case`
- Comment "why" not "what" - code shows what, comments explain why

## DEBUGGING & LOGGING

- Use `console.error()` for errors
- Use `console.warn()` for warnings
- Use `console.log()` sparingly in development
- Remove all console.log before production (use eslint rule)
- Consider using a logger utility for production logging

## SECURITY

- Never expose sensitive data in client-side code
- Sanitize user input before rendering (Vue does this by default)
- Use HTTPS for all API calls
- Validate data on backend - never trust client validation alone
- Don't store sensitive tokens in localStorage - use httpOnly cookies when possible

## TESTING (Future)

- Use Vitest for unit tests
- Use @vue/test-utils for component testing
- Test composables and utilities
- Mock API calls in tests

## GIT & COMMITS

- Write clear, descriptive commit messages
- Follow conventional commits format: `<type>(<scope>): <subject>`
- Types: feat, fix, docs, style, refactor, perf, test, chore, ci, build, revert
- Subject line: max 50 characters, imperative mood, no period
- Body (optional): wrap at 72 characters, explain what and why
- Footer (optional): reference issues with "Closes #123" or "Fixes #456"
- Breaking changes: add "BREAKING CHANGE: description" in footer
- Examples:
  - `feat(auth): add OAuth2 login support`
  - `fix(api): prevent race condition in user update`
  - `docs(readme): update installation instructions`
  - `chore(deps): upgrade vue to 3.4.0`
- Don't commit node_modules, dist, or .env files
- Always ask for scope clarification if unclear

## CODE REVIEW CHECKLIST

- TypeScript types are properly defined
- No `any` types used
- Components use Composition API with `<script setup>`
- Path aliases (`@/`) are used instead of relative paths
- Mobile/webview considerations are addressed
- Error handling is implemented
- Code follows DRY principles
- Styles use SCSS and CSS variables

## COMMON PATTERNS

### Component Pattern

```vue
<template>
  <div class="component-name">
    <!-- Template content -->
  </div>
</template>

<script setup lang="ts">
import type { ComponentProps } from '@/types'

interface Props {
  // props definition
}

const props = withDefaults(defineProps<Props>(), {
  // defaults
})

const emit = defineEmits<{
  event: [payload: Type]
}>()

// Component logic
</script>

<style scoped lang="scss">
.component-name {
  // Styles
}
</style>
```
